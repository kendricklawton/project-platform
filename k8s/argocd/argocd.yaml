# ArgoCD Installation and Configuration for K3s
#
# Prerequisites:
#   - K3s cluster with Cilium CNI
#   - Namespaces created (kubectl apply -f k8s/security/02-namespaces.yaml)
#
# Installation Steps:
#   1. Install ArgoCD:
#      kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
#
#   2. Apply this configuration:
#      kubectl apply -f k8s/argocd/argocd.yaml
#
#   3. Get initial admin password:
#      kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
#
#   4. Access ArgoCD UI via Tailscale:
#      kubectl port-forward svc/argocd-server -n argocd 8080:443
#      Open: https://localhost:8080
#
---
# ArgoCD ConfigMap - Core Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cm
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-cm
    app.kubernetes.io/part-of: argocd
data:
  # Repository credentials template (use external-secrets in production)
  # repositories: |
  #   - url: https://github.com/your-org/your-repo.git
  #     passwordSecret:
  #       name: github-creds
  #       key: password
  #     usernameSecret:
  #       name: github-creds
  #       key: username

  # Enable status badge
  statusbadge.enabled: "true"

  # Application health checks
  resource.customizations.health.networking.k8s.io_Ingress: |
    hs = {}
    hs.status = "Healthy"
    return hs

  # Knative health check
  resource.customizations.health.serving.knative.dev_Service: |
    hs = {}
    if obj.status ~= nil then
      if obj.status.conditions ~= nil then
        for i, condition in ipairs(obj.status.conditions) do
          if condition.type == "Ready" and condition.status == "True" then
            hs.status = "Healthy"
            hs.message = condition.message
            return hs
          end
          if condition.type == "Ready" and condition.status == "False" then
            hs.status = "Degraded"
            hs.message = condition.message
            return hs
          end
        end
      end
    end
    hs.status = "Progressing"
    hs.message = "Waiting for Knative Service to be ready"
    return hs

  # Exclude high-churn resources from diffing
  resource.exclusions: |
    - apiGroups:
        - cilium.io
      kinds:
        - CiliumIdentity
      clusters:
        - "*"
---
# ArgoCD RBAC Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-rbac-cm
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-rbac-cm
    app.kubernetes.io/part-of: argocd
data:
  # Default policy: read-only for all authenticated users
  policy.default: role:readonly

  # Admin policy - replace with your actual users/groups
  policy.csv: |
    # Admins can do everything
    p, role:admin, applications, *, */*, allow
    p, role:admin, clusters, *, *, allow
    p, role:admin, repositories, *, *, allow
    p, role:admin, logs, *, *, allow
    p, role:admin, exec, *, */*, allow

    # Developers can sync and view applications in their namespaces
    p, role:developer, applications, get, */*, allow
    p, role:developer, applications, sync, */*, allow
    p, role:developer, logs, get, */*, allow

    # Production namespace requires admin
    p, role:developer, applications, sync, production/*, deny

    # Assign roles (replace with your actual users)
    # g, admin@yourdomain.com, role:admin
    # g, dev-team, role:developer

  # Enable OIDC scopes for group mapping
  scopes: "[groups]"
---
# ArgoCD Server Configuration - Insecure mode for Tailscale access
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cmd-params-cm
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-cmd-params-cm
    app.kubernetes.io/part-of: argocd
data:
  # Run insecure (TLS termination handled by Tailscale/ingress)
  server.insecure: "true"
  # Disable TLS on repo server
  reposerver.disable.tls: "true"
---
# ArgoCD Notifications Configuration (optional)
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-notifications-cm
  namespace: argocd
data:
  # Slack notification template (configure webhook in secrets)
  template.app-deployed: |
    message: |
      {{if eq .serviceType "slack"}}:white_check_mark:{{end}} Application {{.app.metadata.name}} is now {{.app.status.sync.status}}.
  template.app-health-degraded: |
    message: |
      {{if eq .serviceType "slack"}}:exclamation:{{end}} Application {{.app.metadata.name}} health is {{.app.status.health.status}}.
  template.app-sync-failed: |
    message: |
      {{if eq .serviceType "slack"}}:x:{{end}} Application {{.app.metadata.name}} sync failed.

  # Triggers
  trigger.on-deployed: |
    - when: app.status.sync.status == 'Synced'
      send: [app-deployed]
  trigger.on-health-degraded: |
    - when: app.status.health.status == 'Degraded'
      send: [app-health-degraded]
  trigger.on-sync-failed: |
    - when: app.status.sync.status == 'OutOfSync' and app.status.operationState.phase == 'Failed'
      send: [app-sync-failed]
---
# Cilium Network Policy for ArgoCD
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: argocd-policy
  namespace: argocd
spec:
  description: "Allow ArgoCD components to communicate"
  endpointSelector: {}
  ingress:
    # Allow from within cluster (UI access via port-forward/Tailscale)
    - fromEntities:
        - cluster
        - host
    # Allow webhook callbacks
    - fromEntities:
        - world
      toPorts:
        - ports:
            - port: "8080"
              protocol: TCP
  egress:
    # Allow to cluster (deploy to namespaces)
    - toEntities:
        - cluster
    # Allow to Kubernetes API
    - toEntities:
        - host
      toPorts:
        - ports:
            - port: "6443"
              protocol: TCP
    # Allow to Git repositories (GitHub, GitLab, etc.)
    - toFQDNs:
        - matchName: "github.com"
        - matchName: "api.github.com"
        - matchPattern: "*.github.com"
        - matchName: "gitlab.com"
        - matchPattern: "*.gitlab.com"
      toPorts:
        - ports:
            - port: "443"
              protocol: TCP
            - port: "22"
              protocol: TCP
    # Allow to Helm repositories
    - toFQDNs:
        - matchPattern: "*.githubusercontent.com"
        - matchPattern: "charts.jetstack.io"
        - matchPattern: "charts.cilium.io"
        - matchPattern: "helm.cilium.io"
      toPorts:
        - ports:
            - port: "443"
              protocol: TCP
    # Allow to container registries
    - toFQDNs:
        - matchPattern: "*.gcr.io"
        - matchPattern: "ghcr.io"
        - matchPattern: "*.pkg.dev"
        - matchPattern: "*.docker.io"
        - matchPattern: "registry-1.docker.io"
      toPorts:
        - ports:
            - port: "443"
              protocol: TCP
---
# ArgoCD Application - Bootstrap (self-manage ArgoCD)
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: argocd
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  source:
    repoURL: https://github.com/YOUR_ORG/YOUR_REPO.git  # Replace with your repo
    targetRevision: HEAD
    path: k8s/argocd
  destination:
    server: https://kubernetes.default.svc
    namespace: argocd
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=false
---
# ArgoCD AppProject for Platform Infrastructure
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: platform
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Platform infrastructure components
  sourceRepos:
    - '*'
  destinations:
    - namespace: kube-system
      server: https://kubernetes.default.svc
    - namespace: cert-manager
      server: https://kubernetes.default.svc
    - namespace: knative-serving
      server: https://kubernetes.default.svc
    - namespace: kourier-system
      server: https://kubernetes.default.svc
    - namespace: argocd
      server: https://kubernetes.default.svc
  clusterResourceWhitelist:
    - group: '*'
      kind: '*'
  namespaceResourceWhitelist:
    - group: '*'
      kind: '*'
---
# ArgoCD AppProject for Applications
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: applications
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Application workloads
  sourceRepos:
    - '*'
  destinations:
    - namespace: production
      server: https://kubernetes.default.svc
    - namespace: staging
      server: https://kubernetes.default.svc
    - namespace: development
      server: https://kubernetes.default.svc
  clusterResourceWhitelist:
    - group: ''
      kind: Namespace
    - group: 'serving.knative.dev'
      kind: '*'
    - group: 'cert-manager.io'
      kind: Certificate
  namespaceResourceWhitelist:
    - group: '*'
      kind: '*'
  # Deny privileged containers in application namespaces
  roles:
    - name: developer
      description: Developer access to applications
      policies:
        - p, proj:applications:developer, applications, get, applications/*, allow
        - p, proj:applications:developer, applications, sync, applications/*, allow
      groups:
        - dev-team
