package main

import (
	"context"
	"log"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/kendricklawton/project-platform/core/internal/config"
	"github.com/kendricklawton/project-platform/core/internal/k8s"
)

func main() {
	cfg, _ := config.Load()

	// Use pgxpool for advanced Postgres features like LISTEN/NOTIFY
	dbPool, err := pgxpool.New(context.Background(), cfg.DatabaseURL)
	if err != nil { log.Fatal(err) }
	defer dbPool.Close()

	k8sClient, err := k8s.NewClient(cfg.KubeConfigPath)
	if err != nil { log.Fatal(err) }

	log.Println("ðŸ‘· Build Worker Started. Waiting for jobs...")

	// The high-speed Listener Loop
	conn, err := dbPool.Acquire(context.Background())
	if err != nil { log.Fatal(err) }
	defer conn.Release()

	// Listen to a Postgres channel called 'new_deployments'
	_, err = conn.Exec(context.Background(), "LISTEN new_deployments")
	if err != nil { log.Fatal(err) }

	for {
		// This blocks until the API sends a NOTIFY, consuming zero CPU
		notification, err := conn.Conn().WaitForNotification(context.Background())
		if err != nil { continue }

		deploymentID := notification.Payload
		log.Printf("ðŸš€ Instant Trigger: Starting build for %s", deploymentID)

		// 1. Fetch deployment details from DB
		// 2. Spawn isolated K8s Job via k8sClient
		go runBuildJob(k8sClient, deploymentID)
	}
}

// runBuildJob talks to K3s to spin up the actual isolated pod
func runBuildJob(client *k8s.Client, deploymentID string) {
	// e.g., client.Clientset.BatchV1().Jobs("builds").Create(...)
	// Inside this pod, `ko` or `cargo` will run.
}
